const { visitorsCont, usersCont } = require("../handler");
const asyncRedis = require("async-redis");
const Q = require("q");
const { ui, errorModel } = require("../../helpers");
const col = require("chalk");
const moment = require("moment");
const _ = require("lodash");
const common = require("./common");
const time = () => moment().format("dddd, MMMM Do YYYY, h:mm a");
function FetchData(client) {
  this.client = client;
  this.bucket = "transferStatics";
  this.subBucket = "auto";
  return {
    getTransferStaticsData: async () => {
      let reply = await this.client.hget(this.bucket, this.subBucket);
      reply = reply ? JSON.parse(reply) : {};
      return reply;
    },
    setTransferStaticsData: async reply => {
      return await this.client.hset(
        this.bucket,
        this.subBucket,
        JSON.stringify(reply)
      );
    }
  };
}

const prepareData = buckets => {
  let operators = Object.assign({}, usersCont, visitorsCont);
  let _allVisi = Object.keys(visitorsCont);
  let _allUsers = Object.keys(usersCont);
  let allVisi = buckets.indexOf("all_visitor_buckets");
  if (allVisi > -1) buckets.splice(allVisi, 1, ..._allVisi);
  let allUsers = buckets.indexOf("all_user_buckets");
  if (allUsers > -1) buckets.splice(allUsers, 1, ..._allUsers);
  decoratedBuckets = _.uniq(buckets);
  return { decoratedBuckets, operators };
};
const saveFunction = async ({
  decoratedBuckets,
  operators,
  fetch,
  client,
  transferPeriod
}) => {
  let deferred = Q.defer();
  let staticsBucket = decoratedBuckets.join(":");
  let firstBucket = decoratedBuckets.shift();
  let Arr = [];
  let interval = setInterval(() => {
    console.log(ui.horizontalLine);
    Arr.push(operators[firstBucket](client));
    _.forEach(decoratedBuckets, elem => {
      let arrLength = Arr.length - 1;
      let currentBucket = operators[elem];
      Arr.push(Arr[arrLength].then(currentBucket));
      Arr.shift();
    });
    Arr[0]
      .then(async () => {
        try {
          let reply = await fetch.getTransferStaticsData();
          reply[time()] = staticsBucket.split(":");
          await fetch.setTransferStaticsData(reply);
        } catch (err) {
          deferred.reject(
            errorModel("AutoTransfer", "StoreTransferStatics", err)
          );
        }
      })
      .catch(async reason => {
        if (reason) deferred.reject(reason);
        try {
          let reply = await fetch.getTransferStaticsData();
          reply[time()] = "fail";
          await fetch.setTransferStaticsData(reply);
        } catch (err) {
          deferred.reject(
            errorModel("AutoTransfer", "StoreTransferStatics", err)
          );
        }
      });
  }, transferPeriod);
  deferred.resolve({
    interval,
    statisticLog: common.statisticLog({
      time: time(),
      staticsBucket
    })
  });
  return deferred.promise;
};

const store = Q.fbind(({ fetch, buckets, transferPeriod, client }) => {
  let { decoratedBuckets, operators } = prepareData(buckets);
  return  saveFunction({
    operators,
    decoratedBuckets,
    fetch,
    client,
    transferPeriod
  });
});

module.exports = (redis, buckets, transferPeriod) => {
  let deferred = Q.defer();
  let client = asyncRedis.decorate(redis);
  transferPeriod = transferPeriod.replace("hour", "");
  transferPeriod = +transferPeriod * 1000 * 60 * 60;
  transferPeriod = 50 * 1000;
  common.uiBeforeComplete(time());
  Q({ fetch: FetchData(client), buckets, transferPeriod, client })
    .then(store)
    .then(deferred.resolve)
    .catch(deferred.reject);
  return deferred.promise;
};
